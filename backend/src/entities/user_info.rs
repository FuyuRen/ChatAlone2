//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use chrono::Utc;
use sea_orm::ActiveValue;
use sea_orm::entity::prelude::*;
use crate::id::{GeneralId, UserId};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(schema_name = "chat", table_name = "user_info")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub username: String,
    pub password: String,
    #[sea_orm(unique)]
    pub email: String,
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::assoc_lone_user::Entity")]
    AssocLoneUser,
    #[sea_orm(has_many = "super::assoc_room_user::Entity")]
    AssocRoomUser,
    #[sea_orm(has_many = "super::lone_info::Entity")]
    LoneInfo,
}

impl Related<super::assoc_lone_user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AssocLoneUser.def()
    }
}

impl Related<super::assoc_room_user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AssocRoomUser.def()
    }
}

impl Related<super::lone_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::LoneInfo.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}


pub struct UserTable {
    is_customized:  bool, // if set true, keys with default val won't be passed to db
    user_id:        UserId,
    email:          String,
    username:       String,
    password:       String,
    register_time:  DateTime,
}

impl UserTable {
    pub fn from_val(email: &str, username: &str, password: &str, id: i32, time: DateTime) -> Self {
        UserTable {
            is_customized:  true,
            user_id:        UserId::from_decoded(id as u32),
            email:          email.to_string(),
            username:       username.to_string(),
            password:       password.to_string(),
            register_time:  time,
        }
    }
    
    pub fn new(email: &str, username: &str, password: &str) -> Self {
        Self::from_val(email, username, password, 0, Utc::now().naive_utc())
    }
    
    pub fn verify_password(&self, password: &String) -> bool {
        self.password.eq(password)
    }
    
    pub fn uid(&self) -> UserId {
        self.user_id
    }
}

impl From<Model> for UserTable {
    fn from(model: Model) -> Self {
        UserTable {
            is_customized:  false,
            user_id:        UserId::from_decoded(model.id as u32),
            email:          model.email,
            username:       model.username,
            password:       model.password,
            register_time:  model.created_at,
        }
    }
}

impl Into<ActiveModel> for UserTable {
    fn into(self) -> ActiveModel {
        if self.is_customized {
            ActiveModel {
                id:             ActiveValue::NotSet,
                email:          ActiveValue::Set(self.email),
                username:       ActiveValue::Set(self.username),
                password:       ActiveValue::Set(self.password),
                created_at:     ActiveValue::NotSet,
            }
        } else {
            ActiveModel {
                id:             ActiveValue::Set(self.user_id.decode() as i32),
                email:          ActiveValue::Set(self.email),
                username:       ActiveValue::Set(self.username),
                password:       ActiveValue::Set(self.password),
                created_at:     ActiveValue::Set(self.register_time),
            }
        }
    }
}

impl Into<Model> for UserTable {
    fn into(self) -> Model {
        Model {
            id:             self.user_id.decode() as i32,
            email:          self.email,
            username:       self.username,
            password:       self.password,
            created_at:     self.register_time,
        }
    }
}