//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use chrono::{NaiveDateTime, Utc};
use sea_orm::ActiveValue;
use sea_orm::entity::prelude::*;
use crate::id::{GeneralId, Id, LoneId, RoomId};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(schema_name = "chat", table_name = "room_info")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub lone_id: i32,
    pub name: String,
    pub room_type: String,
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::assoc_room_user::Entity")]
    AssocRoomUser,
    #[sea_orm(
        belongs_to = "super::lone_info::Entity",
        from = "Column::LoneId",
        to = "super::lone_info::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    LoneInfo,
    #[sea_orm(has_many = "super::room_identity_info::Entity")]
    RoomIdentityInfo,
}

impl Related<super::assoc_room_user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AssocRoomUser.def()
    }
}

impl Related<super::lone_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::LoneInfo.def()
    }
}

impl Related<super::room_identity_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RoomIdentityInfo.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}


pub enum RoomType {
    Text,
    Voice,
}

impl From<&str> for RoomType {
    fn from(s: &str) -> Self {
        match s {
            "text" => RoomType::Text,
            "voice" => RoomType::Voice,
            _ => panic!("Invalid room type"),
        }
    }
}
impl Into<String> for RoomType {
    fn into(self) -> String {
        match self {
            RoomType::Text => "text".to_string(),
            RoomType::Voice => "voice".to_string(),
        }
    }
}

pub struct RoomTable {
    is_customized:  bool, // if set true, keys with default val won't be passed to db
    pub room_id:    RoomId,
    lone_id:        LoneId,
    room_name:      String,
    room_type:      RoomType,
    created_at:     DateTime,
}



impl RoomTable {
    pub fn from_val(
        room_id: RoomId,
        lone_id: LoneId,
        room_name: &str,
        room_type: RoomType,
        time: DateTime
    ) -> Self {
        RoomTable {
            is_customized:  true,
            room_id,
            lone_id,
            room_type,
            room_name:      room_name.to_string(),
            created_at:     time,
        }
    }

    pub fn new(lone_id: LoneId, room_name: &str, room_type: RoomType) -> Self {
        Self::from_val(
            RoomId::from_decoded(0),
            lone_id,
            room_name,
            room_type,
            // Utc::now().naive_utc()
            NaiveDateTime::default()
        )
    }

    pub fn room_id(&self) -> RoomId {
        self.room_id
    }
}


impl From<Model> for RoomTable {
    fn from(model: Model) -> Self {
        RoomTable {
            is_customized:  false,
            room_id:        RoomId::from_decoded(model.id as u32),
            lone_id:        RoomId::from_decoded(model.lone_id as u32),
            room_type:      RoomType::from(model.room_type.as_ref()),
            room_name:      model.name,
            created_at:     model.created_at,
        }
    }
}

impl Into<ActiveModel> for RoomTable {
    fn into(self) -> ActiveModel {
        if self.is_customized {
            ActiveModel {
                id:         ActiveValue::NotSet,
                lone_id:    ActiveValue::Set(self.lone_id.decode() as i32),
                name:       ActiveValue::Set(self.room_name),
                room_type:  ActiveValue::Set(self.room_type.into()),
                created_at: ActiveValue::NotSet,
            }
        } else {
            ActiveModel {
                id:         ActiveValue::Set(self.room_id.decode() as i32),
                lone_id:    ActiveValue::Set(self.lone_id.decode() as i32),
                name:       ActiveValue::Set(self.room_name),
                room_type:  ActiveValue::Set(self.room_type.into()),
                created_at: ActiveValue::Set(self.created_at),
            }
        }
    }
}

impl Into<Model> for RoomTable {
    fn into(self) -> Model {
        Model {
            id:         self.room_id.decode() as i32,
            lone_id:    self.lone_id.decode() as i32,
            name:       self.room_name,
            room_type:  self.room_type.into(),
            created_at: self.created_at,
        }
    }
}