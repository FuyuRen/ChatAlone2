//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use chrono::Utc;
use sea_orm::ActiveValue;
use sea_orm::entity::prelude::*;
use crate::id::{GeneralId, LoneId, UserId};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(schema_name = "chat", table_name = "lone_info")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    #[sea_orm(unique)]
    pub owner_id: i32,
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::assoc_lone_user::Entity")]
    AssocLoneUser,
    #[sea_orm(has_many = "super::lone_role_info::Entity")]
    LoneRoleInfo,
    #[sea_orm(has_many = "super::room_info::Entity")]
    RoomInfo,
    #[sea_orm(
        belongs_to = "super::user_info::Entity",
        from = "Column::OwnerId",
        to = "super::user_info::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    UserInfo,
}

impl Related<super::assoc_lone_user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AssocLoneUser.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::assoc_lone_user::Relation::UserInfo.def().rev())
    }
}

impl Related<super::lone_role_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::LoneRoleInfo.def()
    }
}

impl Related<super::room_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RoomInfo.def()
    }
}

impl Related<super::user_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::UserInfo.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}


pub struct LoneTable {
    is_customized:      bool,
    pub id:             LoneId,
    pub owner_uid:      UserId,
    pub name:           String,
    pub created_at:     DateTime,
}

impl LoneTable {
    pub fn from_val(id: i32, owner_uid: i32, name: &str, time: DateTime) -> Self {
        LoneTable {
            is_customized:  true,
            id:             LoneId::from_decoded(id as u32),
            owner_uid:      LoneId::from_decoded(owner_uid as u32),
            name:           name.to_string(),
            created_at:     time,
        }
    }

    pub fn new(owner_uid: i32, name: &str) -> Self {
        Self::from_val(0, owner_uid, name, Utc::now().naive_utc())
    }

    pub fn id(&self) -> LoneId {
        self.id
    }

    pub fn owner(&self) -> UserId {
        self.owner_uid
    }
}

impl From<Model> for LoneTable {
    fn from(model: Model) -> Self {
        LoneTable {
            is_customized:  false,
            id:             LoneId::from_decoded(model.id as u32),
            owner_uid:      LoneId::from_decoded(model.owner_id as u32),
            name:           model.name,
            created_at:     model.created_at,
        }
    }
}

impl Into<ActiveModel> for LoneTable {
    fn into(self) -> ActiveModel {
        if self.is_customized {
            ActiveModel {
                id:             ActiveValue::NotSet,
                owner_id:       ActiveValue::Set(self.owner_uid.decode() as i32),
                name:           ActiveValue::Set(self.name),
                created_at:     ActiveValue::NotSet,
            }
        } else {
            ActiveModel {
                id:             ActiveValue::Set(self.id.decode() as i32),
                owner_id:       ActiveValue::Set(self.owner_uid.decode() as i32),
                name:           ActiveValue::Set(self.name),
                created_at:     ActiveValue::Set(self.created_at),
            }
        }
    }
}

impl Into<Model> for LoneTable {
    fn into(self) -> Model {
        Model {
            id:             self.id.decode() as i32,
            owner_id:       self.owner_uid.decode() as i32,
            name:           self.name,
            created_at:     self.created_at,
        }
    }
}